//! https://github.com/Prakhar-002/LEETCODE

// Todo ðŸ’Ž QUESTION NUMBER 564

//? âŒš Time complexity âžº O(1)

//? ðŸ§º Space complexity âžº O(1)

class Solution {
      public String nearestPalindromic(String numberStr) {
            // it converts `numberStr` to a long integer `number`
            long number = Long.parseLong(numberStr);

            // special checks for numbers less than or equal to 10
            if (number <= 10)
                  // returning `number - 1` 
                  return String.valueOf(number - 1);

            // special checks for numbers equals 11
            if (number == 11)
                  // returning `9`
                  return "9";

            // Determines the length of the number
            int length = numberStr.length();

            // calculates the `leftHalf` of the number
            // If the number's length is odd, the middle digit is also considered part of the left half
            long leftHalf = Long.parseLong(numberStr.substring(0, (length + 1) / 2));

            // If the number's length is odd, the middle digit is also considered part of the left half
            long[] palindromeCandidates = new long[5];

            // either decrementing by 1 then mirroring it to create a full palindrome
            palindromeCandidates[0] = generatePalindromeFromLeft(leftHalf - 1, length % 2 == 0);
            // keeping as is it then mirroring it to create a full palindrome
            palindromeCandidates[1] = generatePalindromeFromLeft(leftHalf, length % 2 == 0);
            // or incrementing the left half by 1 then mirroring it to create a full palindrome
            palindromeCandidates[2] = generatePalindromeFromLeft(leftHalf + 1, length % 2 == 0);

            // Two additional candidates are generated by taking ->

            // -> 10 to the power of (length-1) - 1
            // represent the largest palindrome of the shorter length
            palindromeCandidates[3] = (long) Math.pow(10, length - 1) - 1; 

            // -> 10 to the power of length + 1
            //  the smallest palindrome of the next longer length
            palindromeCandidates[4] = (long) Math.pow(10, length) + 1;   

            long nearestPalindrome = 0;
            long minDifference = Long.MAX_VALUE;

            // It then iterates over all candidates
            for (long candidate : palindromeCandidates) {

                  //  If thereâ€™s a tie, the smaller number is chosen.
                  if (candidate == number)
                        continue;

                  // to  find the one with the smallest absolute difference from the original number
                  long difference = Math.abs(candidate - number);
                  if (difference < minDifference || (difference == minDifference && candidate < nearestPalindrome)) {
                        minDifference = difference;
                        nearestPalindrome = candidate;
                  }
            }

            // return the palindrome as a string
            return String.valueOf(nearestPalindrome);
      }

      // The method checks whether the number's length is even or odd to decide whether the middle digit should be mirrored
      private long generatePalindromeFromLeft(long leftHalf, boolean isEvenLength) {
            long palindrome = leftHalf;

            // If the original number's length is odd
            if (!isEvenLength)
                  // it first discards the last digit of the `leftHalf`
                  leftHalf /= 10;

            // mirrors it to generate a palindrome
            while (leftHalf > 0) {
                  // iterating over the `leftHalf`, taking each digit from the end, 
                  // and appending it to `palindrome` 
                  palindrome = palindrome * 10 + leftHalf % 10;
                  leftHalf /= 10;
            }

            // return new palindrome generated by mirroring the left half
            return palindrome;
      }
}
