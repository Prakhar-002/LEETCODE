//! https://github.com/Prakhar-002/LEETCODE

// Todo ðŸ’Ž QUESTION NUMBER 564

//? âŒš Time complexity âžº O(1)

//? ðŸ§º Space complexity âžº O(1)

// Function to find the nearest palindromic number
function nearestPalindromic(numberStr) {
      // it converts `numberStr` to a BigInt `number`
      let number = BigInt(numberStr);

      // special checks for numbers less than or equal to 10
      if (number <= 10n)
            // returning `number - 1`
            return String(number - 1n);

      // special checks for numbers equals 11
      if (number === 11n)
            // returning `9`
            return "9";

      // Determines the length of the number
      let length = numberStr.length;

      // calculates the `leftHalf` of the number
      // If the number's length is odd, the middle digit is also considered part of
      // the left half
      let leftHalf = BigInt(numberStr.substring(0, Math.floor((length + 1) / 2)));

      // If the number's length is odd, the middle digit is also considered part of the left half
      let palindromeCandidates = [
            // either decrementing by 1 then mirroring it to create a full palindrome
            generatePalindromeFromLeft(leftHalf - 1n, length % 2 === 0),

            // keeping as is it then mirroring it to create a full palindrome
            generatePalindromeFromLeft(leftHalf, length % 2 === 0),

            // or incrementing the left half by 1 then mirroring it to create a full palindrome
            generatePalindromeFromLeft(leftHalf + 1n, length % 2 === 0),

            // Two additional candidates are generated by taking ->

            // -> 10 to the power of (length-1) - 1
            // represent the largest palindrome of the shorter length
            BigInt(10n ** BigInt(length - 1) - 1n),

            // -> 10 to the power of length + 1
            // the smallest palindrome of the next longer length
            BigInt(10n ** BigInt(length) + 1n)
      ];

      let nearestPalindrome = 0n;
      let minDifference = BigInt(Number.MAX_SAFE_INTEGER);

      // It then iterates over all candidates
      for (let candidate of palindromeCandidates) {
            // If there's a tie, the smaller number is chosen.
            if (candidate === number)
                  continue;

            // to find the one with the smallest absolute difference from the original number
            let difference = candidate > number ? candidate - number : number - candidate;
            if (difference < minDifference || (difference === minDifference && candidate < nearestPalindrome)) {
                  minDifference = difference;
                  nearestPalindrome = candidate;
            }
      }

      // return the palindrome as a string
      return nearestPalindrome.toString();
}

// The method checks whether the number's length is even or odd to decide
// whether the middle digit should be mirrored
function generatePalindromeFromLeft(leftHalf, isEvenLength) {
      let palindrome = leftHalf;

      // If the original number's length is odd
      if (!isEvenLength)
            // it first discards the last digit of the `leftHalf`
            leftHalf = leftHalf / 10n;

      // mirrors it to generate a palindrome
      while (leftHalf > 0n) {
            // iterating over the `leftHalf`, taking each digit from the end,
            // and appending it to `palindrome`
            palindrome = palindrome * 10n + leftHalf % 10n;
            leftHalf = leftHalf / 10n;
      }

      // return new palindrome generated by mirroring the left half
      return palindrome;
}

