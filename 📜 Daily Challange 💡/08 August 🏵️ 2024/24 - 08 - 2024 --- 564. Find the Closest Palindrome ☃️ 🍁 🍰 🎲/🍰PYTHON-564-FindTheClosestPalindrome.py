#! https://github.com/Prakhar-002/LEETCODE

# Todo ðŸ’Ž QUESTION NUMBER 564

#? âŒš Time complexity âžº O(1)

#? ðŸ§º Space complexity âžº O(1)

class Solution:
      def nearestPalindromic(self, numberStr: str) -> str:
            # it converts `numberStr` to an integer `number`
            number = int(numberStr)

            # special checks for numbers less than or equal to 10
            if number <= 10:
                  # returning `number - 1`
                  return str(number - 1)

            # special checks for numbers equals 11
            if number == 11:
                  # returning `9`
                  return "9"

            # Determines the length of the number
            length = len(numberStr)

            # calculates the `leftHalf` of the number
            # If the number's length is odd, the middle digit is also considered part of the left half
            leftHalf = int(numberStr[:(length + 1) // 2])

            # If the number's length is odd, the middle digit is also considered part of
            # the left half
            palindromeCandidates = [
                  # either decrementing by 1 then mirroring it to create a full palindrome
                  self.generatePalindromeFromLeft(leftHalf - 1, length % 2 == 0),

                  # keeping as is it then mirroring it to create a full palindrome
                  self.generatePalindromeFromLeft(leftHalf, length % 2 == 0),

                  # or incrementing the left half by 1 then mirroring it to create a full palindrome
                  self.generatePalindromeFromLeft(leftHalf + 1, length % 2 == 0),

                  # Two additional candidates are generated by taking ->

                  # -> 10 to the power of (length-1) - 1
                  # represent the largest palindrome of the shorter length
                  10 ** (length - 1) - 1,

                  # -> 10 to the power of length + 1
                  # the smallest palindrome of the next longer length
                  10 ** length + 1
            ]

            nearestPalindrome = 0
            minDifference = float('inf')

            # It then iterates over all candidates
            for candidate in palindromeCandidates:
                  # If there's a tie, the smaller number is chosen.
                  if candidate == number:
                        continue

                  # to find the one with the smallest absolute difference from the original number
                  difference = abs(candidate - number)
                  if difference < minDifference or (difference == minDifference and candidate < nearestPalindrome):
                        minDifference = difference
                        nearestPalindrome = candidate

            # return the palindrome as a string
            return str(nearestPalindrome)

      # The method checks whether the number's length is even or odd to decide
      # whether the middle digit should be mirrored
      def generatePalindromeFromLeft(self, leftHalf: int, isEvenLength: bool) -> int:
            palindrome = leftHalf

            # If the original number's length is odd
            if not isEvenLength:
                  # it first discards the last digit of the `leftHalf`
                  leftHalf //= 10

            # mirrors it to generate a palindrome
            while leftHalf > 0:
                  # iterating over the `leftHalf`, taking each digit from the end,
                  # and appending it to `palindrome`
                  palindrome = palindrome * 10 + leftHalf % 10
                  leftHalf //= 10

            # return new palindrome generated by mirroring the left half
            return palindrome

